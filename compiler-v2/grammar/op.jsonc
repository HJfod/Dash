{
    // Base expression without any unary operators or index accesses
    "base-expr": {
        "grammar": [
            { "if": { "peek": "var" },    "then": [{ "return": "#var-decl" }] },
            { "if": { "peek": "let" },    "then": [{ "return": "#const-decl" }] },
            { "if": { "peek": "fun" },    "then": [{ "return": "#fun-decl" }] },
            { "if": { "peek": "struct" }, "then": [{ "return": "#struct-decl" }] },
            { "if": { "peek": "if" },     "then": [{ "return": "#if" }] },
            { "if": { "peek": "while" },  "then": [{ "return": "#while" }] },
            { "if": { "peek": "return" }, "then": [{ "return": "#return" }] },
            { "if": { "peek": "using" },  "then": [{ "return": "#using-path" }] },
            { "if": { "peek": "ident" },  "then": [{ "return": "#entity" }] },
            { "if": { "peek": "::" },     "then": [{ "return": "#entity" }] },
            { "if": { "peek": "void" },   "then": [{ "return": "#void-lit" }] },
            { "if": { "peek": "true" },   "then": [{ "return": "#bool-lit" }] },
            { "if": { "peek": "false" },  "then": [{ "return": "#bool-lit" }] },
            { "if": { "peek": "int" },    "then": [{ "return": "#int-lit" }] },
            { "if": { "peek": "float" },  "then": [{ "return": "#float-lit" }] },
            { "if": { "peek": "string" }, "then": [{ "return": "#string-lit" }] },
            { "expected": "expression" }
        ]
    },
    // Function call like `target(a, b)`
    "callop": {
        "members": ["target", "+args"],
        "grammar": [
            {
                "if": { "not": { "set": "target" } },
                "then": [{ "match": "#base-expr", "into": "target" }]
            },
            {
                "match": "(...)",
                "inner": [{
                    "while": { "not": { "peek": "eof" } },
                    "then": [
                        { "match": "#expr", "into": "args" },
                        // Allow trailing commas. Expect EOF if no comma provided
                        { "if": { "match": "," }, "then": [], "else": [{ "match": "eof:)" }] }
                    ]
                }]
            }
        ]
    },
    // Index access like `a[0]`
    "indexop": {
        "members": ["target", "index"],
        "grammar": [
            {
                "if": { "not": { "set": "target" } },
                "then": [{ "match": "#base-expr", "into": "target" }]
            },
            {
                "match": "[...]",
                "inner": [
                    { "match": "#expr", "into": "index" },
                    // Allow trailing comma
                    { "if": { "match": "," }, "then": [] },
                    // Expect EOF
                    { "match": "eof:]" }
                ]
            }
        ]
    },
    // Match a chain of suffix unary operators, like calls, indexes, and member 
    // accesses
    "--match-suffix-expr": {
        "members": ["--temp"],
        "grammar": [
            { "match": "#base-expr", "into": "--temp" },
            {
                "while": { "peek": ["(...)", "[...]"] },
                "then": [
                    {
                        "if": { "peek": "(...)" },
                        "then": [{
                            "match": "#callop",
                            "with": {
                                "target": "--temp"
                            },
                            "into": "--temp"
                        }]
                    },
                    {
                        "if": { "peek": "[...]" },
                        "then": [{
                            "match": "#indexop",
                            "with": {
                                "target": "--temp"
                            },
                            "into": "--temp"
                        }]
                    }
                ]
            },
            { "return": ":--temp" }
        ]
    },
    // Unary operation like `+a`
    "unop": {
        "members": ["op", "target"],
        "grammar": [
            { "match": ["+", "-", "!"], "into": "op" },
            { "match": "#--match-unop-or-suffix", "into": "target" }
        ]
    },
    // Match a bunch of unary operators or a suffixed expression
    "--match-unop-or-suffix": {
        "grammar": [{
            "if": { "peek": "op" },
            "then": [{ "return": "#unop" }],
            "else": [{ "return": "#--match-suffix-expr" }]
        }]
    },
    "--match-binop-prec-muldiv": {
        "members": ["--temp-rhs", "--temp-op", "--temp-lhs"],
        "grammar": [
            { "match": "#--match-unop-or-suffix", "into": "--temp-lhs" },
            {
                "while": {
                    "match": ["*", "/", "%"],
                    "into": "--temp-op"
                },
                "then": [
                    { "match": "#--match-unop-or-suffix", "into": "--temp-rhs" },
                    {
                        "match": "#binop",
                        "with": {
                            "lhs": "--temp-lhs",
                            "op": "--temp-op",
                            "rhs": "--temp-rhs"
                        },
                        "into": "--temp-lhs"
                    }
                ]
            },
            { "return": ":--temp-lhs" }
        ]
    },
    "--match-binop-prec-addsub": {
        "members": ["--temp-rhs", "--temp-op", "--temp-lhs"],
        "grammar": [
            { "match": "#--match-binop-prec-muldiv", "into": "--temp-lhs" },
            {
                "while": {
                    "match": ["+", "-"],
                    "into": "--temp-op"
                },
                "then": [
                    { "match": "#--match-binop-prec-muldiv", "into": "--temp-rhs" },
                    {
                        "match": "#binop",
                        "with": {
                            "lhs": "--temp-lhs",
                            "op": "--temp-op",
                            "rhs": "--temp-rhs"
                        },
                        "into": "--temp-lhs"
                    }
                ]
            },
            { "return": ":--temp-lhs" }
        ]
    },
    "--match-binop-prec-ord": {
        "members": ["--temp-rhs", "--temp-op", "--temp-lhs"],
        "grammar": [
            { "match": "#--match-binop-prec-addsub", "into": "--temp-lhs" },
            {
                "while": {
                    "match": ["<", ">", "<=", ">="],
                    "into": "--temp-op"
                },
                "then": [
                    { "match": "#--match-binop-prec-addsub", "into": "--temp-rhs" },
                    {
                        "match": "#binop",
                        "with": {
                            "lhs": "--temp-lhs",
                            "op": "--temp-op",
                            "rhs": "--temp-rhs"
                        },
                        "into": "--temp-lhs"
                    }
                ]
            },
            { "return": ":--temp-lhs" }
        ]
    },
    "--match-binop-prec-eq": {
        "members": ["--temp-rhs", "--temp-op", "--temp-lhs"],
        "grammar": [
            { "match": "#--match-binop-prec-ord", "into": "--temp-lhs" },
            {
                "while": {
                    "match": ["==", "!="],
                    "into": "--temp-op"
                },
                "then": [
                    { "match": "#--match-binop-prec-ord", "into": "--temp-rhs" },
                    {
                        "match": "#binop",
                        "with": {
                            "lhs": "--temp-lhs",
                            "op": "--temp-op",
                            "rhs": "--temp-rhs"
                        },
                        "into": "--temp-lhs"
                    }
                ]
            },
            { "return": ":--temp-lhs" }
        ]
    },
    "--match-binop-prec-andor": {
        "members": ["--temp-rhs", "--temp-op", "--temp-lhs"],
        "grammar": [
            { "match": "#--match-binop-prec-eq", "into": "--temp-lhs" },
            {
                "while": {
                    "match": ["&&", "||"],
                    "into": "--temp-op"
                },
                "then": [
                    { "match": "#--match-binop-prec-eq", "into": "--temp-rhs" },
                    {
                        "match": "#binop",
                        "with": {
                            "lhs": "--temp-lhs",
                            "op": "--temp-op",
                            "rhs": "--temp-rhs"
                        },
                        "into": "--temp-lhs"
                    }
                ]
            },
            { "return": ":--temp-lhs" }
        ]
    },
    "--match-binop-prec-seq": {
        "members": ["--temp-rhs", "--temp-op", "--temp-lhs"],
        "grammar": [
            { "match": "#--match-binop-prec-andor", "into": "--temp-lhs" },
            {
                "while": {
                    "match": ["=", "+=", "-=", "*=", "/=", "%="],
                    "into": "--temp-op"
                },
                "then": [
                    { "match": "#--match-binop-prec-andor", "into": "--temp-rhs" },
                    {
                        "match": "#binop",
                        // todo: RTL
                        "with": {
                            "lhs": "--temp-lhs",
                            "op": "--temp-op",
                            "rhs": "--temp-rhs"
                        },
                        "into": "--temp-lhs"
                    }
                ]
            },
            { "return": ":--temp-lhs" }
        ]
    },
    "--match-expr": {
        "grammar": [{ "return": "#--match-binop-prec-seq" }]
    },
    // Binary operation like `a + b`
    // Can not be matched directly as this has no grammar; instead, use the 
    // `--match-expr` rule
    "binop": {
        "members": ["lhs", "op", "rhs"],
        "grammar": []
    }
}
