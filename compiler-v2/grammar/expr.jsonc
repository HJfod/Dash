
{
    "keywords": {
        "strict": [
            // Literals
            "void", "true", "false", "none",
            // Constants & special variables
            "this", "super",
            // Declarations
            "var", "let", "fun", "struct", "enum", "using",
            "macro", "extends", "module", "type",
            // Prepositions
            "in", "is", "as", "where", "from",
            // Loops & conditionals
            "if", "else", "for", "while",
            // Control flow
            "try", "return", "break", "continue",
            // Visibility
            "extern", "public", "private",
            // Types
            "typeof", "const",
            // Other
            "codegen", "compiler_intrinsic"
        ],
        "contextual": [
            "get", "set", "assert", "default"
        ],
        "reserved": [
            // Declarations
            "trait", "class", "interface",
            // Control flow
            "unwrap", "yield", "match", "switch",
            // Visibility
            "export", "import",
            // Reactivity
            "depends", "required",
            // Other
            "mut", "mutable", "new", "null"
        ]
    },
    "rules": {
        "ident-path": {
            "members": ["+parts"],
            "grammar": [
                { "match": "ident", "into": "parts" },
                {
                    "while": { "match": "::" },
                    "then": [
                        { "match": "ident", "into": "parts" }
                    ]
                }
            ]
        },
        "block": {
            "members": ["list"],
            "grammar": [
                {
                    "match": "{}",
                    "inner": [
                        { "match": "#expr-list", "into": "list" }
                    ]
                }
            ]
        },
        "expr": {
            "grammar": [
                { "if": { "peek": "let" }, "then": [{ "return": "#let" }] },
                { "if": { "peek": "fun" }, "then": [{ "return": "#fun-decl" }] },
                { "if": { "peek": "if" }, "then": [{ "return": "#if" }] },
                { "if": { "peek": "while" }, "then": [{ "return": "#while" }] },
                { "if": { "peek": "void" }, "then": [{ "return": "#void-lit" }] },
                { "if": { "peek": "true" }, "then": [{ "return": "#bool-lit" }] },
                { "if": { "peek": "false" }, "then": [{ "return": "#bool-lit" }] },
                { "if": { "peek": "int" }, "then": [{ "return": "#int-lit" }] },
                { "if": { "peek": "float" }, "then": [{ "return": "#float-lit" }] },
                { "if": { "peek": "string" }, "then": [{ "return": "#string-lit" }] },
                { "expected": "expression" }
            ]
        },
        "expr-list": {
            "members": ["+list"],
            "grammar": [
                {
                    "while": "not-eof",
                    "then": [
                        { "match": "#expr", "into": "list" },
                        // Semicolons are optional because I cba to figure out a proper 
                        // way to match them in a reasonable way
                        { "while": { "match": ";" }, "then": [] }
                    ]
                }
            ]
        },
        "main": {
            "grammar": [{ "return": "#expr-list" }]
        }
    }
}
